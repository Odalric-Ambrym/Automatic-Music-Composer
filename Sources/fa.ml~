(* Functional Abstraction *)


(* Notes :*)
(* duree modifiers *)
(* valeur modifiers *)
(* artic modifiers *)
(* nuance modifiers *)

(* Groupes :*)
(* Notes modifiers *)

(*
let aux   notes = 
   List.fold_left (+.) 0.
   (List.map (function (x:abstract_note) -> x#duree_reelle) notes);;

let aux2 l s =
  match (s mod 2,l) with
    | _,[] -> []
    | 0,d::q -> 8 8 -> 2/3 4 8

let ternaire ln =
  let ld = List.map (function (x:abstract_note) -> x#duree) notes in
  let s = ref 0 in
    for i=1 to length ld do
      if (s mod 2 = 0) then
	
    done

;;*)

let notesMTogrM m = 
fun (g:abstract_groupe) -> 
 new abstract_groupe  (m g#notes) (g#artic) (g#gamme) (g#hauteur) (g#nuance);;
(* Artic modifiers *)
let articMTogrM m = 
fun (g:abstract_groupe) -> 
 new abstract_groupe  (g#notes) (m g#artic) (g#gamme) (g#hauteur) (g#nuance);;
(* Gamme modifiers *)
let gTodorien g:gamme = 
 new gamme (g#i) (-1) 0 (-1) 0 0 0;;


let gammesMTogrM m = 
fun (g:abstract_groupe) -> 
 new abstract_groupe  (g#notes) (g#artic) (m g#gamme) (g#hauteur) (g#nuance);;
(* Hauteur modifiers *)
let hauteurMTogrM m = 
fun (g:abstract_groupe) -> 
 new abstract_groupe  (g#notes) (g#artic) (g#gamme) (m g#hauteur) (g#nuance);;
(* Nuance modifiers *)
let nuanceMTogrM m = 
fun (g:abstract_groupe) -> 
 new abstract_groupe  (g#notes) (g#artic) (g#gamme) (g#hauteur) (m g#nuance);;

(* Phrases : *)

let grMTopM m = 
fun (p:abstract_phrase) -> 
  new abstract_phrase (List.map m (p#groupes));;


